# 델타

## MOTIVE

```
AWS IOT SHADOW에서는 상태값이 변경 되면 거기서 변경 된 상태값을 delta로 제공한다.
그러면 변경 된 상태의 집합인 delta의 요소에 대한 핸들러만 실행하면 된다.
이로 인해 얻을 수 있는 장점은 그저 이벤트로 상태만 변경하면 변경 된 상태의 핸들로 실행으로 RP의 특성을 가지게 되고, 선언적 프로그래밍을 하게 된다.

그리고 각 상태가 서로에게 의존성이 없이 독립적으로 동작하여 참조투명성을 유지하도록하여 부수효과를 제거하여 버그발생율의 감소를 꾀한다.

+ 유한상태기계의 특성도 넣는다. => RX와 다를바 없어진다(추구하는 개념의 공통점 떄문일까 익숙해서일까) => 지정상태에서는 상태에 의존하는 전이만 사용가능하도록한다.
```

## GOAL

**유한상태(의존이 생기는 상태)에서 state(data)가 업데이트 되면 조건에 따라 핸들러를실행하도록 한다**


## 라이브러리 원칙

1. 유한상태기계인 밀리머신으로 한다.
```
1-1. 입력과 현재상태로 다음상태(출력)을 결정한다.
1-2. 상태전이를 위한 함수를 등록한다.
```

2. 머신의 상태요소는 하나의 핸들러를 가진다.
```
2-1. 핸들러는 순수함수이다.
2-2. 핸들러는 RP를 위함이며 상태와 관련된 뷰 렌더링을 담당한다.
```

3. 상태 구성
```
3-1. 무조건 독립적인 상태만 있을수 없으므로, 서로 영향을 주는 상태의 핸들러는 객체로 묶는다. 객체가 독립적이 된다.
ex)
state: {
    NESTED_STATE: {
        A: a,
        B: b
    }
}

const NESTED_STATE_HANDLER = (A, B) => 처리;
```
4. 트랜잭션
```
4-1 전이함수가 모두 끝나고 상태 업데이트가 적용되도록 원자성을 갖게한다.
만약 실패한다면 상태는 업데이트 되지않고 이전 상태를 유지한다.

# 적용
Atomicity: 상태는 적용이 되거나 안된거로 유지(부분적용 없음)
Isolation: 독립적으로 작업수행
Durability: 성공적으로 수행된 트랜잭션은 영원히 반영됨

# 적용 안함
Consistency: 상태변경 후에도 일관적으로 유지
  - 상태의 타입까지는 적용하지 않고싶다. 만약 하고싶다면 typescript쓰던가

4-2 독립성
만약 같은상태를 조작하는 전이가 두개가 시작된다면 이산적으로 실행되고, JS엔진 특성상 콜스택이 하나밖에없으므로 먼저 들어오는 전이함수 실행 후 다음것이 실행된다.
그러므로 앞의 트랜잭션이 실행이 되든안되든 원자성이 적용이 된다면 앞의 트랜잭션으로 바뀐 최신상태로 된다고 추측된다(이거 검증이 필요하다.)
```

5. Handler
```
option = {
    ...
    state: {
        NAME: ANITING
    },
    handler: {
        //  상태와 같은 키, 갱신된 상태를 파라미터로 제공
        NAME: CURRENT_STATE[NAME] => 처리
    }
}
```

## 생각의 문제점

1. FP + RP의 특성을 가져온다면 RX가 아닌가?
```
맞다 확실히 그런 느낌이있어서 유한상태 머신의 특성도 가져와서 생각해보자 한다.

원칙을 추가하여 이를 해결한다.
```

2. stent보다 나은점
```
stent의 코딩 syntax를 받아옴

RP를 위해서 독립적인 렌더링을 위해서 상태 별 핸들러를 추가한점
```

3. 트랜잭션
```
전이함수가 모두 끝나고 상태가 더 이상 변하지 않은상황에서 렌더링을 해야한다.
왜냐하면 부수효과를 줄이기위해 상태는 업데이트됫는데 전이함수의 이후 부분에서 에러가 발생한다면 원래 상태가 업데이트 되기전의 상태로 되야하는 원자성을 유지해야한다.
```

4. 시간
```
RX가 진정한 FRP가 아니라고 꼬집는점은 시간이란 요소가 없다.
시간이 없어서 FRP에서는 동시성이벤트를 지원하는데, rxjs는 모두 이산적인 시간의 흐름이다

이 라이브러리에서는 동시성이벤트를 지원할것인가 하는 생각.

안하려고한다
이유: 동시성 이벤트가 그렇게 크게 필요한가라는 생각이들고 (rxjs는 없어도 잘 나간다) 동시성이벤트에서 얻는 장점은 글리치현상이 안일어 난다인데 일반 대부분의 웹사이트에서는 글리치 현상이 크게 중요치않아서 무시할수 있다고 생각된다. (물론 안일어나는게 좋지만)
그리고 유저경험에서 쉽게 알지는 못한다.
```

5. 비동기
```
전이 할 때 서버의 값에따라 상태를 변해야 할 때가있다.
그렇다면 비동기를 사용하는데 비동기 값을 라이브러리에서 지원해줘야 할까라는 생각이 들었다.

1. 비동기 지원할 경우
전이 함수 실행시 비동기를 지원 할 경우 문제는 트랜잭션이다. 콜스택을이용해서 내부에서 하나씩 처리하는거를 예상했는데 비동기를 한경우 트랜잭션의 독립성이 깨진다.(상태가 생각했던 순서대로 바뀌지 않는다.) 그래서 이를 해결해서 비동기를 지원해야하는데 그렇다면 트랜잭션을 위한 뚜렷하게 코드상에서 지원을 위한 코드를 추가적으로 더 작성해야한다.

2. 외부에서 한다면
유저가 직접 외부에서 데이터를 요청 후 payload를 통해 파라미터로 제공한다면 굳이 내부에서 지원할 필요는없다. 하지만 유저가 비동기 처리에 대한 책임이 위임된다.
A작업과 B작업이 AJAX콜이 일어난 후 A, B를 순차적으로 실행한다면 유저개발자는 순차적으로 이를 실행하도록 해야한다.

3. 선택은 ?
이를 예상하고 있는 라이브러리 상에서 지원하는게 유저개발자에게 편한게 맞지만 반대로 유저개발자에게 지켜야하는 규약을 추가하는것이다. 그리고 외부에서 전이함수를 제공할때 전달할때 async키워드를 함께하는 방법을 가이드한다면 이 부분은 해결된다고 생각된다.
```