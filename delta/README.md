# 델타

## MOTIVE

```
AWS IOT SHADOW에서는 상태값이 변경 되면 거기서 변경 된 상태값을 delta로 제공한다.
그러면 변경 된 상태의 집합인 delta의 요소에 대한 핸들러만 실행하면 된다.
이로 인해 얻을 수 있는 장점은 그저 이벤트로 상태만 변경하면 변경 된 상태의 핸들로 실행으로 RP의 특성을 가지게 되고, 선언적 프로그래밍을 하게 된다.

그리고 각 상태가 서로에게 의존성이 없이 독립적으로 동작하여 참조투명성을 유지하도록하여 부수효과를 제거하여 버그발생율의 감소를 꾀한다.

+ 유한상태기계의 특성도 넣는다. => RX와 다를바 없어진다(추구하는 개념의 공통점 떄문일까 익숙해서일까) => 지정상태에서는 상태에 의존하는 전이만 사용가능하도록한다.
```

## GOAL

**유한상태(의존이 생기는 상태)에서 state(data)가 업데이트 되면 조건에 따라 핸들러를실행하도록 한다**


## 라이브러리 원칙

1. 유한상태기계인 밀리머신으로 한다.
```
1-1. 입력과 현재상태로 다음상태(출력)을 결정한다.
1-2. 상태전이를 위한 함수를 등록한다.
```

2. 머신의 상태요소는 하나의 핸들러를 가진다.
```
2-1. 핸들러는 순수함수이다.
2-2. 핸들러는 RP를 위함이며 상태와 관련된 뷰 렌더링을 담당한다.
```

3. 상태 구성
```
3-1. 무조건 독립적인 상태만 있을수 없으므로, 서로 영향을 주는 상태의 핸들러는 객체로 묶는다. 객체가 독립적이 된다.
ex)
state: {
    NESTED_STATE: {
        A: a,
        B: b
    }
}

const NESTED_STATE_HANDLER = (A, B) => 처리;
```
4. 트랜잭션
```
4-1 전이함수가 모두 끝나고 상태 업데이트가 적용되도록 원자성을 갖게한다.
만약 실패한다면 상태는 업데이트 되지않고 이전 상태를 유지한다.
```

## 생각의 문제점

1. FP + RP의 특성을 가져온다면 RX가 아닌가?
```
맞다 확실히 그런 느낌이있어서 유한상태 머신의 특성도 가져와서 생각해보자 한다.

원칙을 추가하여 이를 해결한다.
```

2. stent보다 나은점
```
stent의 코딩 syntax를 받아옴

RP를 위해서 독립적인 렌더링을 위해서 상태 별 핸들러를 추가한점
```

3. 트랜잭션
```
전이함수가 모두 끝나고 상태가 더 이상 변하지 않은상황에서 렌더링을 해야한다.
왜냐하면 부수효과를 줄이기위해 상태는 업데이트됫는데 전이함수의 이후 부분에서 에러가 발생한다면 원래 상태가 업데이트 되기전의 상태로 되야하는 원자성을 유지해야한다.
```