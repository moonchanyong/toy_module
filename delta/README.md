# 델타

## MOTIVE

```
AWS IOT SHADOW에서는 상태값이 변경 되면 거기서 변경 된 상태값을 delta로 제공한다.
그러면 변경 된 상태의 집합인 delta의 요소에 대한 핸들러만 실행하면 된다.
이로 인해 얻을 수 있는 장점은 그저 이벤트로 상태만 변경하면 변경 된 상태의 핸들로 실행으로 RP의 특성을 가지게 되고, 선언적 프로그래밍을 하게 된다.

그리고 각 상태가 서로에게 의존성이 없이 독립적으로 동작하여 참조투명성을 유지하도록하여 부수효과를 제거하여 버그발생율의 감소를 꾀한다.

+ 유한상태기계의 특성도 넣는다. => RX와 다를바 없어진다(추구하는 개념의 공통점 떄문일까 익숙해서일까) => 지정상태에서는 상태에 의존하는 전이만 사용가능하도록한다.
```

## GOAL

**유한상태(의존이 생기는 상태)에서 state(data)가 업데이트 되면 조건에 따라 핸들러를실행하도록 한다**


## 라이브러리 원칙

1. 유한상태기계인 밀리머신으로 한다.
```
1-1. 입력과 현재상태로 다음상태(출력)을 결정한다.
1-2. 상태전이를 위한 함수를 등록한다.
```

2. 머신의 상태요소는 하나의 핸들러를 가진다.
```
2-1. 핸들러는 순수함수이다.
2-2. 핸들러는 RP를 위함이며 상태와 관련된 뷰 렌더링을 담당한다.
```

3. 상태 구성
```
3-1. 무조건 독립적인 상태만 있을수 없으므로, 서로 영향을 주는 상태의 핸들러는 객체로 묶는다. 객체가 독립적이 된다.
ex)
state: {
    NESTED_STATE: {
        A: a,
        B: b
    }
}

const NESTED_STATE_HANDLER = (A, B) => 처리;
```
4. 트랜잭션
```
4-1 전이함수가 모두 끝나고 상태 업데이트가 적용되도록 원자성을 갖게한다.
만약 실패한다면 상태는 업데이트 되지않고 이전 상태를 유지한다.

# 적용
Atomicity: 상태는 적용이 되거나 안된거로 유지(부분적용 없음)
Isolation: 독립적으로 작업수행
Durability: 성공적으로 수행된 트랜잭션은 영원히 반영됨

# 적용 안함
Consistency: 상태변경 후에도 일관적으로 유지
  - 상태의 타입까지는 적용하지 않고싶다. 만약 하고싶다면 typescript쓰던가

4-2 독립성
만약 같은상태를 조작하는 전이가 두개가 시작된다면 이산적으로 실행되고, JS엔진 특성상 콜스택이 하나밖에없으므로 먼저 들어오는 전이함수 실행 후 다음것이 실행된다.
그러므로 앞의 트랜잭션이 실행이 되든안되든 원자성이 적용이 된다면 앞의 트랜잭션으로 바뀐 최신상태로 된다고 추측된다(이거 검증이 필요하다.)
```

5. Hanler
```
option = {
    ...
    state: {
        NAME: ANITING
    },
    handler: {
        //  상태와 같은 키, 갱신된 상태를 파라미터로 제공
        NAME: CURRENT_STATE[NAME] => 처리
    }
}
```

## 생각의 문제점

1. FP + RP의 특성을 가져온다면 RX가 아닌가?
```
맞다 확실히 그런 느낌이있어서 유한상태 머신의 특성도 가져와서 생각해보자 한다.

원칙을 추가하여 이를 해결한다.
```

2. stent보다 나은점
```
stent의 코딩 syntax를 받아옴

RP를 위해서 독립적인 렌더링을 위해서 상태 별 핸들러를 추가한점
```

3. 트랜잭션
```
전이함수가 모두 끝나고 상태가 더 이상 변하지 않은상황에서 렌더링을 해야한다.
왜냐하면 부수효과를 줄이기위해 상태는 업데이트됫는데 전이함수의 이후 부분에서 에러가 발생한다면 원래 상태가 업데이트 되기전의 상태로 되야하는 원자성을 유지해야한다.
```

4. 시간
```
RX가 진정한 FRP가 아니라고 꼬집는점은 시간이란 요소가 없다.
시간이 없어서 FRP에서는 동시성이벤트를 지원하는데, rxjs는 모두 이산적인 시간의 흐름이다

이 라이브러리에서는 동시성이벤트를 지원할것인가 하는 생각.

안하려고한다
이유: 동시성 이벤트가 그렇게 크게 필요한가라는 생각이들고 (rxjs는 없어도 잘 나간다) 동시성이벤트에서 얻는 장점은 글리치현상이 안일어 난다인데 일반 대부분의 웹사이트에서는 글리치 현상이 크게 중요치않아서 무시할수 있다고 생각된다. (물론 안일어나는게 좋지만)
그리고 유저경험에서 쉽게 알지는 못한다.
```